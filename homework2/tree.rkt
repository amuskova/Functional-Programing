#lang racket/base
(require racket/string)
(require racket/stream)

(provide tree?)
(provide balanced?)
(provide ordered?)
(provide tree->string)
(provide are-streams-equal?)
(provide tree->stream)
(provide is-tree-valid?)

(define (is-digit? c) (and (char>=? c #\0) (char<=? c #\9)))
(define (is-empty? c) (char=? c #\*))
(define (is-space? c) (char=? c #\space))
(define (is-leftscope? c) (char=? c #\{))
(define (is-rightscope? c) (char=? c #\}))
(define (is-enabled? c) (or (is-digit? c) (is-space? c) (is-leftscope? c) (is-rightscope? c) (is-empty? c)))

(define empty-string "")

(define (is-string-empty? str) (= (string-length str) 0))

(define (is-out-of-bounds index str) (or (< index 0) (>= index (string-length str))))
(define (get-char str index)
  (if (or (is-string-empty? str) (is-out-of-bounds index str))
      #\null
      (string-ref str index)
  )
)

(define (remove-last str)
  (if (is-string-empty? str)
      empty-string
      (substring str 0 (- (string-length str) 1))
  )
)

(define (tree? str)
  (define one-space-str (string-normalize-spaces str))
  (define len-one-space-str (string-length one-space-str))
  (define first-symbol (get-char one-space-str 0))
  (define last-symbol (get-char one-space-str (- len-one-space-str 1)))
  (define without-spaces (string-replace one-space-str " " ""))
  (define len-without-spaces (string-length without-spaces))
  
  (define (make-check str i len help stars go-next?)
    (if (char=? go-next? #\f)
        (cond
          ((= i (- len 1)) (make-check without-spaces 0 len-without-spaces "" 0  #\t))
          ((not (is-enabled? (get-char str i))) #f)
          ((and (is-leftscope? (get-char str i)) (is-leftscope? (get-char str (+ i 1)))) #f)
          ((and (is-leftscope? (get-char str i)) (is-rightscope? (get-char str (+ i 1)))) #f)
          ((and (is-space? (get-char str i)) (is-leftscope? (get-char str (- i 1))) (is-leftscope? (get-char str (+ i 1)))) #f)
          ((and (is-space? (get-char str i)) (is-leftscope? (get-char str (- i 1))) (is-rightscope? (get-char str (+ i 1)))) #f)
          ((and (is-space? (get-char str i)) (is-digit? (get-char str (- i 1))) (is-digit? (get-char str (+ i 1)))) #f)
          ((and (is-space? (get-char str i)) (is-digit? (get-char str (- i 1))) (is-rightscope? (get-char str (+ i 1)))) #f)
          (else (make-check str (+ i 1) len help stars #\f))
        )
        (cond
          ((= i len) #t)
          ((and (is-rightscope? (get-char str i)) (is-empty? (get-char help (- (string-length help) 1))) (>= stars 2)) #f)
          ((and (is-rightscope? (get-char str i)) (is-digit? (get-char help (- (string-length help) 1))) (< stars 2)) #f)
          ((and (is-rightscope? (get-char str i)) (is-leftscope? (get-char help (- (string-length help) 1))) (< stars 2)) #f)
          ((and (is-rightscope? (get-char str i)) (is-empty? (get-char help (- (string-length help) 1)))) (make-check str i len (remove-last help) (+ stars 1) #\t))
          ((and (is-rightscope? (get-char str i)) (is-digit? (get-char help (- (string-length help) 1)))) (make-check str i len (remove-last help) stars #\t))
          ((and (is-rightscope? (get-char str i)) (is-leftscope? (get-char help (- (string-length help) 1)))) (make-check str (+ i 1) len (string-append (remove-last help) "*") 0 #\t))
          (else (make-check str (+ i 1) len (string-append help (string (get-char str i))) 0 #\t))
        )
    )
  )
    
  (cond
    ((string=? without-spaces "*") #t)
    ((is-string-empty? one-space-str) #f)
    ((or (not (is-leftscope? first-symbol)) (not (is-rightscope? last-symbol))) #f)
    (else (make-check one-space-str 0 len-one-space-str "" 0 #\f))
  )
)

(define (string->tree str)
  (define (add-in-stack stack e)
     (cons (append (car stack) (list e)) (cdr stack))
  )
  (define (help-string->tree str i len help-str stack)
     (cond
       ((= i (- len 1)) (car stack))
       ((is-leftscope? (get-char str i))
        (help-string->tree str (+ i 1) len "" (cons '() stack)))
       ((and (is-digit? (get-char str i)) (or (is-leftscope? (get-char str (+ i 1))) (is-empty? (get-char str (+ i 1)))))
        (help-string->tree str (+ i 1) len "" (add-in-stack stack (string->number (string-append help-str (get-char str i))))))
       ((is-digit? (get-char str i))
        (help-string->tree str (+ i 1) len (string-append help-str (get-char str i)) stack))
       ((is-empty? (get-char str i))
        (help-string->tree str (+ i 1) len "" (add-in-stack stack '())))
       (else (help-string->tree str (+ i 1) len "" (add-in-stack (cdr stack) (car stack))))
     )
  )

  (define without-spaces-str (string-replace str " " ""))
  (define len-without-spaces-str (string-length without-spaces-str))
  (cond
    ((not (tree? without-spaces-str)) #f)
    ((string=? without-spaces-str "*") '())
    (else (help-string->tree without-spaces-str 0 len-without-spaces-str "" '(())))
  )
)

(define (is-tree-empty? tree) (if (null? tree) #t #f))
(define root-tree car)
(define left-tree cadr)
(define right-tree caddr)

(define (is-tree-valid? tree)
  (cond
    ((is-tree-empty? tree) #t)
    ((not (list? tree)) #f)
    ((not (equal? (length tree) 3)) #f)
    ((not (number? (root-tree tree))) #f)
    ((or (not (is-tree-valid? (left-tree tree))) (not (is-tree-valid? (right-tree tree)))) #f)
    (else #t)
  )
)

(define (balanced? tree)
  (define (height tree)
    (if (is-tree-empty? tree)
       0
       (+ 1 (max (height (left-tree tree))
                 (height (right-tree tree))))
    )
  )
  
  (define (help-balanced? tree)
    (or (is-tree-empty? tree)
        (and (<= (abs(- (height (left-tree tree)) (height (right-tree tree)))) 1)
             (help-balanced? (left-tree tree))
             (help-balanced? (right-tree tree))))
  )
  (if (not (is-tree-valid? tree))
      #f
      (help-balanced? tree)
  )
)

(define (ordered? tree)
  (define (help-ordered? tree parent direction)
    (cond
      ((is-tree-empty? tree) #t)
      ((and (equal? direction 'left) (> (root-tree tree) parent)) #f)
      ((and (equal? direction 'right) (< (root-tree tree) parent)) #f)
      (else (and (help-ordered? (left-tree tree) (root-tree tree) 'left)
                 (help-ordered? (right-tree tree) (root-tree tree) 'right)))
    )
  )
  
  (cond
    ((not (is-tree-valid? tree)) #f)
    ((is-tree-empty? tree) #t)
    (else (and (help-ordered? (left-tree tree) (root-tree tree) 'left)
               (help-ordered? (right-tree tree) (root-tree tree) 'right)))
  )
)

(define (tree->string tree)
  (define (help-tree->string tree)
    (if (is-tree-empty? tree)
       " *"
       (string-append " {"
                      (number->string (root-tree tree))
                      (help-tree->string (left-tree tree))
                      (help-tree->string (right-tree tree))
                      "}")
    )
  )
  (if (not (is-tree-valid? tree))
      ""
      (string-normalize-spaces (help-tree->string tree))
  )
)

(define (are-streams-equal? s1 s2)
  (cond
    ((and (stream-empty? s1) (stream-empty? s2)) #t)
    ((and (stream-empty? s1) (not (stream-empty? s2))) #f)
    ((and (not (stream-empty? s1)) (stream-empty? s2)) #f)
    ((not (equal? (stream-first s1) (stream-first s2))) #f)
    (else (are-streams-equal? (stream-rest s1) (stream-rest s2)))
  )
)

(define (tree->stream tree order)
  (define (preorder tree)
    (if (is-tree-empty? tree)
        '()
        (append (list (root-tree tree)) (preorder (left-tree tree)) (preorder (right-tree tree)))
    )
  )

  (define (inorder tree)
    (if (is-tree-empty? tree)
        '()
        (append (inorder (left-tree tree)) (list (root-tree tree)) (inorder (right-tree tree)))
    )
  )

  (define (postorder tree)
    (if (is-tree-empty? tree)
        '()
        (append (postorder (left-tree tree)) (postorder (right-tree tree)) (list (root-tree tree)))
    )
  )
  
  (define (list->stream xs)
    (if (null? xs)
        empty-stream
        (stream-cons (car xs) (list->stream (cdr xs)))
    )
  )

  (cond
    ((not (is-tree-valid? tree)) empty-stream)
    ((is-tree-empty? tree) empty-stream)
    ((equal? 'preorder order) (list->stream (preorder tree)))
    ((equal? 'inorder order) (list->stream (inorder tree)))
    ((equal? 'postorder order) (list->stream (postorder tree)))
    (else empty-stream)
  )
)